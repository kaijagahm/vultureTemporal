---
title: "temporal"
format: 
  html:
    embed-resources: true
editor: visual
---

```{r}
#| include: false
library(tidyverse) # for data wrangling
library(sf) # for spatial manipulation (necessary as a precursor to getting edgelists)
library(vultureUtils) # for getting edgelists
library(igraph) # for working with networks
library(tidygraph) # for working with networks
library(future) # for parallel processing
library(furrr) # for parallel processing
library(here) # for tidy file paths
source(here("scripts/00_temporal_funs.R"))
```

## Prepare a subset of data

```{r}
#| eval: false
# Load data
load(here("data/fromMvmtSoc/downsampled_10min_forSocial.Rda")) # produced by the dataPrep script in MvmtSoc project

# Convert to SF
sfdata <- map(downsampled_10min_forSocial, ~st_as_sf(.x, coords = c("location_long", "location_lat"), crs = "WGS84", remove = F))

rm(downsampled_10min_forSocial)

# Put all the seasons together and remove the columns we don't need
sfdata <- purrr::list_rbind(sfdata) %>%
  select(-any_of(cols_to_remove)) # cols_to_remove is defined in temporal_funs.R

# For our own sanity, let's just work with a single season: summer 2023
summer23 <- sfdata %>%
  filter(seasonUnique == "2023_summer")

save(summer23, file = here("data/summer23.Rda"))
rm(sfdata)
```

## Load the Summer 2023 data subset

```{r}
#| include: false
load(here("data/summer23.Rda"))
load(here("data/roosts.Rda"))
roostPolygons <- sf::st_read(here("data/raw/roosts50_kde95_cutOffRegion.kml"))
dim(summer23)
```

## Cut Summer 2023 into different time windows

### Define the time windows

To test how the networks behave over different time intervals, we can prepare a subset of data (summer 2023) cut into different intervals. E.g. 1 day, 5 days, 10 days, 25 days, 50 days.

```{r}
#| include: false
# What are the different time windows we want to test?
timewindows <- c(1, 5, 10, 25, 50)
save(timewindows, file = here("data/timewindows.Rda"))

# A function for cutting a vector of dates (`vec`) into `days`-day intervals
cutdates <- function(vec, days){
  # get min and max dates in the vector
  min <- min(vec)
  max <- max(vec)
  
  # determine how many cutpoints we'll need
  ncutpoints <- ceiling(as.numeric(max-min)/days) + 1
  
  # create the vector of cutpoints
  cutpoints <- seq(from = min, by = days, length.out = ncutpoints)
  
  # cut the dates according to the cutpoints. Intervals will have the format [low, high).
  out <- cut(vec, breaks = cutpoints, include.lowest = T, right = F)
  return(out)
}

# Cut the data into the various intervals
data_cut <- map(timewindows, ~{
  summer23 %>%
    mutate(int = cutdates(dateOnly, .x))
})

length(data_cut) # should be same length as `timewindows` vector

# Okay, now we have the data classified into intervals, time to split each one into a list.
# There is an annoying thing here: when you have an sf object and you run group_by() %>% group_split() on it, the resulting sub-objects do not keep their sf status. They turn into regular data frames. Grrrrr! So I had to add a step to turn each of them back into an sf object.
data_cut <- map(data_cut, ~.x %>% 
                  group_by(int) %>% 
                  group_split() %>%
                  map(., ~sf::st_as_sf(.x, coords = c("location_long", "location_lat"), crs = "WGS84", remove = F)))

length(data_cut) # 5 elements, one for each of the time windows
map_dbl(data_cut, length) # each element has a different number of elements--122 for the 1-day intervals, 25 for the 5-day intervals, etc. etc.

save(data_cut, file = here("data/data_cut.Rda"))
```

Now we we need to do the same cuts for the roost data.

```{r}
#| include: false
roosts_summer23 <- roosts[[9]]

roosts_cut <- map(timewindows, ~{
  roosts_summer23 %>%
    mutate(int = cutdates(roost_date, .x))
})

roosts_cut <- map(roosts_cut, ~.x %>% 
                    group_by(int) %>% 
                    group_split() %>%
                    map(., ~sf::st_as_sf(.x, coords = c("location_long", "location_lat"), crs = "WGS84", remove = F)))

save(roosts_cut, file = here("data/roosts_cut.Rda"))
```

## Get flight, feeding, and roosting edges for each time window

I am using an unholy combination of for loops and `purrr::map()` here, because I find it easier to understand than nested `map` statements (and nested for loops are slower/not easy to parallelize). But they are doing the same thing.

```{r}
#| include: false
# Set up a session for parallel computing, with 10 workers (i.e. can run 10 processes in parallel)
future::plan(future::multisession, workers = 15)

# Initialize lists to hold the outputs of get*Edges.
outs_flight <- vector(mode = "list", length = length(timewindows))
outs_feeding <- vector(mode = "list", length = length(timewindows))
outs_roosting <- vector(mode = "list", length = length(timewindows))

# Run a for loop across all the time windows
for(i in 1:length(timewindows)){
  cat("Working on data split into", timewindows[i], "day intervals\n")
  
  datalist <- data_cut[[i]]
  roostlist <- roosts_cut[[i]]
  cat("Working on flight\n")
  fl <- suppressWarnings(furrr::future_map(datalist, ~{
    library(sf) # have to have this here; it's a quirk of future::map().
    vultureUtils::getFlightEdges(.x, roostPolygons = roostPolygons, distThreshold = 1000, idCol = "Nili_id", return = "both")
  }, .progress = T))
  
  cat("Working on feeding\n")
  fe <- suppressWarnings(furrr::future_map(datalist, ~{
   library(sf) # have to have this here; it's a quirk of future::map().
   vultureUtils::getFeedingEdges(.x, roostPolygons = roostPolygons, distThreshold = 50, idCol = "Nili_id", return = "both")
   }, .progress = T))
  
  cat("Working on roosting\n")
  ro <- suppressWarnings(furrr::future_map(roostlist, ~{
    library(sf) # have to have this here; it's a quirk of future::map().
    vultureUtils::getRoostEdges(.x, mode = "distance",
                                distThreshold = 500,
                                return = "both",
                                latCol = "location_lat",
                                longCol = "location_long",
                                idCol = "Nili_id",
                                dateCol = "roost_date")
    
  }, .progress = T))
  
  # Save the results to their lists
  outs_flight[[i]] <- fl
  outs_feeding[[i]] <- fe
  outs_roosting[[i]] <- ro
  
  # Clean up memory
  rm(list = c("datalist", "roostlist", "fl", "fe", "ro"))
  gc()
}

sris_flight <- map(outs_flight, ~map(.x, "sri"))
sris_feeding <- map(outs_feeding, ~map(.x, "sri"))
sris_roosting <- map(outs_roosting, ~map(.x, "sri"))
  
edges_flight <- map(outs_flight, ~map(.x, "edges"))
edges_feeding <- map(outs_feeding, ~map(.x, "edges"))
edges_roosting <- map(outs_roosting, ~map(.x, "edges"))

save(edges_flight, file = here("data/edges_flight.Rda"))
save(edges_feeding, file = here("data/edges_feeding.Rda"))
save(edges_roosting, file = here("data/edges_roosting.Rda"))

# Now we have a problem where some of them have length 0 because there were no interactions of that type during the time interval in question. 
# I want to fill in those with a blank data frame with the same format as the other SRI data frames.
# Function to create empty SRI data frames:
fix <- function(data){
  unique_indivs <- unique(data$Nili_id)
  sri <- as.data.frame(expand.grid(unique_indivs, unique_indivs)) %>%
    setNames(c("ID1", "ID2")) %>%
    mutate(sri = 0) %>%
    filter(as.character(ID1) < as.character(ID2))
  return(sri)
}

for(i in 1:length(timewindows)){
  # In order to fix this, we will need access to the sri objects to check (result of the above) as well as the original data
  cat("Fixing results for time window", timewindows[i], "\n")
  
  # Define the current datasets (both sri and original data objects)
  sri_flight <- sris_flight[[i]]
  sri_feeding <- sris_feeding[[i]]
  sri_roosting <- sris_roosting[[i]]
  data_flight <- data_cut[[i]]
  data_feeding <- data_cut[[i]]
  data_roosting <- roosts_cut[[i]]
  
  # For each sri output, check whether it's blank, and if so, fill it in with an empty data frame (i.e. "fix" it). If it's not blank, just leave it as is.
  flight_edges_fixed <- map2(sri_flight, data_flight, ~{
    if(nrow(.x) > 0){out <- .x}
    else{out <- fix(.y)}
    return(out)
  })
  feeding_edges_fixed <- map2(sri_feeding, data_feeding, ~{
    if(nrow(.x) > 0){out <- .x}
    else{out <- fix(.y)}
    return(out)
  })
  roosting_edges_fixed <- map2(sri_roosting, data_roosting, ~{
    if(nrow(.x) > 0){out <- .x}
    else{out <- fix(.y)}
    return(out)
  })
  
  # Save the results to their lists (overwriting what was there before)
  sris_flight[[i]] <- flight_edges_fixed
  sris_feeding[[i]] <- feeding_edges_fixed
  sris_roosting[[i]] <- roosting_edges_fixed
  
  # Clean up memory
  rm(list = c("sri_feeding", "sri_flight", "sri_roosting", "data_flight", "data_feeding", "data_roosting"))
  gc()
}
```

## Make the network graphs

```{r}
#| include: false
# Create lists to store the network graphs
graphs_flight <- vector(mode = "list", length = length(timewindows))
graphs_feeding <- vector(mode = "list", length = length(timewindows))
graphs_roosting <- vector(mode = "list", length = length(timewindows))

# Set up a "plan" to run this code in parallel, so it will go much faster
future::plan(future::multisession, workers = 15)

# For each time window, loop through the edge lists and turn them into graphs
for(i in 1:length(timewindows)){
  flight <- sris_flight[[i]]
  feeding <- sris_feeding[[i]]
  roosting <- sris_roosting[[i]]
  flightgraphs <- furrr::future_map(flight, ~vultureUtils::makeGraph(mode = "sri", data = .x, weighted = T),
                                    .progress = T)
  feedinggraphs <- furrr::future_map(feeding, ~vultureUtils::makeGraph(mode = "sri", data = .x, weighted = T),
                                     .progress = T)
  roostinggraphs <- furrr::future_map(roosting, ~vultureUtils::makeGraph(mode = "sri", data = .x, weighted = T), .progress = T)
  
  # Fill the lists with the created graphs
  graphs_flight[[i]] <- flightgraphs
  graphs_feeding[[i]] <- feedinggraphs
  graphs_roosting[[i]] <- roostinggraphs
  
  # Clean up memory
  rm(flightgraphs)
  rm(feedinggraphs)
  rm(roostinggraphs)
}

# Save the graphs to files
save(graphs_flight, file = here("data/graphs_flight.Rda"))
save(graphs_feeding, file = here("data/graphs_feeding.Rda"))
save(graphs_roosting, file = here("data/graphs_roosting.Rda"))
```
